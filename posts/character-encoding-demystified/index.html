<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Character Encoding Demystified: Everything you Need to Know About ASCII, Unicode, UTF-8" /><meta name="author" content="Borko Rajkoviƒá" /><meta property="og:locale" content="en" /><meta name="description" content="Character Encoding Demystified is trying to cover everything you need to know about character encoding, including inner mechanisms of ASCII and several character encoding schemes including Unicode (UTF-32, UCS-2, UTF-16 and UTF-8) with examples. You can learn about Endianness, BOM and even find out why there are two separate characters for new line on a different OS. And a lot of other useful information. So, pick what you want to learn and happy reading!" /><meta property="og:description" content="Character Encoding Demystified is trying to cover everything you need to know about character encoding, including inner mechanisms of ASCII and several character encoding schemes including Unicode (UTF-32, UCS-2, UTF-16 and UTF-8) with examples. You can learn about Endianness, BOM and even find out why there are two separate characters for new line on a different OS. And a lot of other useful information. So, pick what you want to learn and happy reading!" /><link rel="canonical" href="https://borkorajkovic.com//posts/character-encoding-demystified/" /><meta property="og:url" content="https://borkorajkovic.com//posts/character-encoding-demystified/" /><meta property="og:site_name" content="Borko Rajkovic Tech Blog" /><meta property="og:image" content="https://borkorajkovic.com//assets/img/posts/2022-07-16-character-encoding-demystified/thumbnail.jpeg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-16T11:50:00+02:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://borkorajkovic.com//assets/img/posts/2022-07-16-character-encoding-demystified/thumbnail.jpeg" /><meta property="twitter:title" content="Character Encoding Demystified: Everything you Need to Know About ASCII, Unicode, UTF-8" /><meta name="twitter:site" content="@borko_88" /><meta name="twitter:creator" content="@borko_88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Borko Rajkoviƒá","url":"https://www.linkedin.com/in/borko-rajkovic/"},"dateModified":"2022-07-25T23:11:04+02:00","datePublished":"2022-07-16T11:50:00+02:00","description":"Character Encoding Demystified is trying to cover everything you need to know about character encoding, including inner mechanisms of ASCII and several character encoding schemes including Unicode (UTF-32, UCS-2, UTF-16 and UTF-8) with examples. You can learn about Endianness, BOM and even find out why there are two separate characters for new line on a different OS. And a lot of other useful information. So, pick what you want to learn and happy reading!","headline":"Character Encoding Demystified: Everything you Need to Know About ASCII, Unicode, UTF-8","image":"https://borkorajkovic.com//assets/img/posts/2022-07-16-character-encoding-demystified/thumbnail.jpeg","mainEntityOfPage":{"@type":"WebPage","@id":"https://borkorajkovic.com//posts/character-encoding-demystified/"},"url":"https://borkorajkovic.com//posts/character-encoding-demystified/"}</script><title>Character Encoding Demystified: Everything you Need to Know About ASCII, Unicode, UTF-8 | Borko Rajkovic Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Borko Rajkovic Tech Blog"><meta name="application-name" content="Borko Rajkovic Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://pbs.twimg.com/profile_images/1484588464163196934/-F7h8gIt_400x400.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Borko Rajkovic Tech Blog</a></div><div class="site-subtitle font-italic">Simple blog about software development</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/borko-rajkovic" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/borko_88" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['rajkovicborko','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Character Encoding Demystified: Everything you Need to Know About ASCII, Unicode, UTF-8</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Character Encoding Demystified: Everything you Need to Know About ASCII, Unicode, UTF-8</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1657965000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 16, 2022 </em> </span> <span> Updated <em class="" data-ts="1658783464" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 25, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/borko-rajkovic/">Borko Rajkoviƒá</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5955 words"> <em>33 min</em> read</span></div></div></div><div class="post-content"><p>Have you ever wondered how exactly a computer stores letters like A, B, C‚Ä¶ or Chinese characters like ÂêÉ, or even some emojis like üòÜ and üöÄ?</p><p>Maybe you are familiar with ASCII and you are aware of Unicode, but you don‚Äôt know exactly how it works?</p><p>In this article, we‚Äôll cover the basics of character encoding and several encoding schemes and introduce some fundamental concepts on the way.</p><hr /><h1 id="evolution-of-data-transmission">Evolution of data transmission</h1><p>Back in the day, when people wanted to communicate over great distances, they had limited options. They could write messages in a form of mail letters and send them over via post service or even use pigeons to fly and carry them over.</p><p>But still, there was a need for immediate communication in cases of emergency like the warning of bad weather, or military communication.</p><p>Over time different civilizations developed quite a few techniques of communication such as smoke signals, church bells, whistling, reflecting sunlight with mirrors, etc. All of these were limited in their capabilities and were generally not suitable for transferring arbitrary messages. They were mostly used to signal if there is some kind of danger ahead or call for help.</p><p>Improved ways of communicating arbitrary messages are called <code class="language-plaintext highlighter-rouge">Telegraphy</code>.</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Telegraphy">Telegraphy</a> is the long-distance transmission of messages where the sender uses symbolic codes, known to the recipient, rather than a physical exchange of an object bearing the message.</p></blockquote><p>Some of the most used and famous telegraph systems are the <a href="https://en.wikipedia.org/wiki/Morse_code">Morse</a> code and <a href="https://en.wikipedia.org/wiki/Flag_semaphore">Flag semaphore</a> (used in maritime and aviation even in the present time).</p><p>As good as they are, these systems were not suitable for computer processing.</p><hr /><h1 id="character-encoding">Character encoding</h1><blockquote><p><strong>Encoding</strong> is a way to convert data from one format to another.</p></blockquote><p>As we all know, computer stores data in a binary format, i.e. ones and zeros. So, to store textual data in computer memory, or transfer it over a digital network, we need a way to represent textual data in a binary format that the computer understands.</p><p>A single unit of textual data is called a <code class="language-plaintext highlighter-rouge">character</code> (or <code class="language-plaintext highlighter-rouge">char</code> in most programming languages). For now, it‚Äôs enough to know that <code class="language-plaintext highlighter-rouge">char</code> can be any sign used for creating textual content, such as a letter of the English alphabet, digit, or some other signs like space, comma, exclamation mark, question mark, etc.</p><blockquote><p>A <strong>character encoding</strong> is a <strong>way to convert text data into binary numbers</strong>.</p></blockquote><p>Essentially, encoding is a process of assigning <strong>unique numeric values</strong> to specific <strong>characters</strong> and converting those numbers into binary language. These binary numbers later can be converted back (or <code class="language-plaintext highlighter-rouge">decoded</code>) to original characters based on their values.</p><blockquote><p><strong>Character set</strong> is simply a mapping between binary numbers and characters.</p></blockquote><p>Simply put, <code class="language-plaintext highlighter-rouge">character set</code> is an <strong>agreement</strong> that defines the <strong>correlation</strong> between binary numbers and characters from a <code class="language-plaintext highlighter-rouge">character set</code>.</p><hr /><h1 id="creating-character-set">Creating character set</h1><p>What would you do if you were to make up your character set for the English language?</p><p>Probably you would take all letters from the English alphabet both upper and lower case:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz
</pre></table></code></div></div><p>Then, you would add digits as well:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>0123456789
</pre></table></code></div></div><p>Also, you would need space, comma, semicolon, and other signs that complement letters and digits:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>&lt;space&gt;!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~
</pre></table></code></div></div><p>If you count these up, you will get 95 distinct characters:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789 !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~
</pre></table></code></div></div><p>To represent 95 characters, we need at least 7 bits, which allows us to define <code class="language-plaintext highlighter-rouge">2^7 = 128</code> characters.</p><p>Now, we can make up a table that will contain the mapping between each binary number and character from the set we just defined.</p><p>We could make A = 0000 0001, B = 0000 0010 and so on‚Ä¶ Or in any other way we like.</p><hr /><h1 id="what-are-fonts-">What are fonts ü§î?</h1><p>Most surely you heard of and used many different fonts on a computer. It must be obvious by now, that the character set is only defining <strong>what</strong> is sent, not how it <strong>looks</strong>.</p><p>When we are referring to a character as ‚ÄúA‚Äù or ‚ÄúB‚Äù, we have a common understanding of what it means (it‚Äôs the Platonic <strong>‚Äúidea‚Äù</strong> of a particular character). But we can all read and write the same characters in different variations (shapes).</p><p>A font is a collection of <em>glyph</em> definitions, in other words, the shapes (or images) that are associated with the character they represent.</p><p>Simple as that üôÇ.</p><hr /><h1 id="ascii">ASCII</h1><p>We‚Äôve shown that at least 7 bits are needed to represent characters used for creating textual content in the English alphabet.</p><p>As with most things in engineering, character sets (encodings) should be standardized.</p><p>One such (most famous) 7-bit encoding is <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> (based on <a href="https://en.wikipedia.org/wiki/Telegraph_code">Telegraph code</a>).</p><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/Ascii_table.gif" alt="Ascii table" data-proofer-ignore></p><p>ASCII table has arranged characters in a very elegant fashion.</p><p>For example, all the uppercase and lowercase letters are in their alphabetical order. The same goes for digits.</p><p>You can easily learn ASCII code for the character <code class="language-plaintext highlighter-rouge">A</code>, character <code class="language-plaintext highlighter-rouge">a</code> and character <code class="language-plaintext highlighter-rouge">0</code> because they are arranged in such an elegant way:</p><ul><li>Character <code class="language-plaintext highlighter-rouge">A</code> starts with 1, followed by all zeros and 1 (as the first letter in the alphabet) at the end: 100 0001<li>Lower case letters have the same ASCII codes as upper case letters, with the second digit being 1 instead of 0. It‚Äôs easy now to find <code class="language-plaintext highlighter-rouge">a</code> - just take <code class="language-plaintext highlighter-rouge">A</code> 1000001 and flip the second digit to 1, you get 110 0001<li>Digit zero is 010 0000</ul><p>A summary of these characters is given here in a table:</p><div class="table-wrapper"><table><thead><tr><th>Character<th>Binary representation<th>Rule<tbody><tr><td>A<td>100 0001<td>Starts with 1, has all zeros, and 1 at the end<tr><td>a<td>110 0001<td>Starts with 11, has all zeros and 1 at the end<tr><td>0<td>010 0000<td>Starts with 01, has all zeros</table></div><p>Now you can derive any other letter/digit by simply counting up to the one you need.</p><hr /><h2 id="cr-and-lf"><span class="mr-2">CR and LF</span><a href="#cr-and-lf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Extra 35 spaces were used to represent some special, so-called ‚Äúcontrol‚Äù characters.</p><p>Some would be <code class="language-plaintext highlighter-rouge">BS</code> (backspace), <code class="language-plaintext highlighter-rouge">DEL</code> (delete), <code class="language-plaintext highlighter-rouge">TAB</code> (horizontal tab).</p><p>Let‚Äôs take a look at two particularly interesting examples. Namely, telegraph machines would require 2 operations to go to the next line when printing text:</p><p><code class="language-plaintext highlighter-rouge">CR</code> - Carriage return</p><p><code class="language-plaintext highlighter-rouge">LF</code> - Line feed</p><p>It‚Äôs based on manual typewriter machines like this one:</p><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/Typewriter.png" alt="Ascii table" data-proofer-ignore></p><p>When you type text and come to the right end of the page, you would like to go to the next line.</p><p>So, you would first push the handle on the left side (marked as <code class="language-plaintext highlighter-rouge">1</code> on the picture) to the right to move the <code class="language-plaintext highlighter-rouge">carriage</code>, hence <code class="language-plaintext highlighter-rouge">CR</code> (Carriage return).</p><p>The next step is to ‚Äúfeed‚Äù the typewriter with more next line of paper with a knob either on the right end of the carriage (market as <code class="language-plaintext highlighter-rouge">2</code> on the picture). Hence, <code class="language-plaintext highlighter-rouge">LF</code> (Line feed).</p><p>This brought confusion to users of different OS, as there is no standardized end-of-line notation:</p><div class="table-wrapper"><table><thead><tr><th>Operating system<th>End-of-line notation<tbody><tr><td>Linux<td><code class="language-plaintext highlighter-rouge">LF</code><tr><td>Windows<td><code class="language-plaintext highlighter-rouge">CR</code> <code class="language-plaintext highlighter-rouge">LF</code><tr><td>MAC (up through version 9)<td><code class="language-plaintext highlighter-rouge">CR</code><tr><td>MAC OS X<td><code class="language-plaintext highlighter-rouge">LF</code></table></div><p>In most programming languages non-printable characters are represented using so-called <code class="language-plaintext highlighter-rouge">escaped</code> character notation, usually with a backslash character <code class="language-plaintext highlighter-rouge">\</code>.</p><p>Some examples are given here:</p><div class="table-wrapper"><table><thead><tr><th>Character<th>Escaped<tbody><tr><td><code class="language-plaintext highlighter-rouge">CR</code><td><code class="language-plaintext highlighter-rouge">\r</code><tr><td><code class="language-plaintext highlighter-rouge">LF</code><td><code class="language-plaintext highlighter-rouge">\n</code><tr><td><code class="language-plaintext highlighter-rouge">TAB</code><td><code class="language-plaintext highlighter-rouge">\t</code></table></div><hr /><h2 id="ascii-encoding-example"><span class="mr-2">ASCII encoding example</span><a href="#ascii-encoding-example" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Let‚Äôs now try to encode text <code class="language-plaintext highlighter-rouge">Hello World!</code> in ASCII.</p><p>It would get you something like this:</p><div class="table-wrapper"><table><thead><tr><th>Character<th>Dec<th>Hex<th>Binary<tbody><tr><td>H<td>72<td>48<td>100 1000<tr><td>e<td>101<td>65<td>110 0101<tr><td>l<td>108<td>6c<td>110 1100<tr><td>l<td>108<td>6c<td>110 1100<tr><td>o<td>111<td>6f<td>110 1111<tr><td>&lt;space&gt;<td>32<td>20<td>010 0000<tr><td>W<td>87<td>57<td>101 0111<tr><td>o<td>111<td>6f<td>110 1111<tr><td>r<td>114<td>72<td>111 0010<tr><td>l<td>108<td>6c<td>110 1100<tr><td>d<td>100<td>64<td>110 0100<tr><td>!<td>33<td>21<td>010 0001</table></div><hr /><h2 id="what-about-the-8th-bit"><span class="mr-2">What about the 8th bit?</span><a href="#what-about-the-8th-bit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A byte is the smallest unit of storage that a computer would use. You may think that since the beginnings of the computing era byte was always 8 bits long. But that is not the case, as you can see with ASCII, which uses 7 bits. ASCII was standardized in 1963, but the first commercial 8-bit CPU came out in 1972. And as late as 1993 it was formally standardized that a byte is 8 bits long.</p><p>For modern CPUs byte is 8 bits long, so when storing ASCII characters, you are left with one extra bit.</p><p>All original text encoded with 7-bit ASCII can be encoded in 8-bit simply by appending 0 to the left side of the binary code, so its decimal and hexadecimal value stay the same.</p><p>Now, taking our last example we can finally write it in the 8-bit format:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>H        e        l        l        o        &lt;space&gt;  W        o        r        l        d        !
01001000 01100101 01101100 01101100 01101111 00100000 01010111 01101111 01110010 01101100 01100100 00100001
</pre></table></code></div></div><p>One question arises here: can we somehow leverage this extra bit ü§î?</p><p>This 8th bit allows us to have another 128 spaces for new characters, right?</p><hr /><h1 id="extended-ascii-code-pages">Extended ASCII (Code pages)</h1><p>Encodings that are using same mappings for ASCII printable characters are called Extended ASCII and are commonly referred to as <code class="language-plaintext highlighter-rouge">Code pages</code>. They guarantee that all ASCII encoded files can be processed with these extended encodings.</p><blockquote><p>One popular 8-bit encoding scheme that was not ASCII compatible is <strong>EBCDIC</strong>, which was used on proprietary IBM PCs.</p></blockquote><p>Instead of just one, we have a huge number of standardized <code class="language-plaintext highlighter-rouge">code pages</code>. A full list of code pages can be found on Wikipedia: https://en.wikipedia.org/wiki/Code_page</p><p>Some of the most known are:</p><ul><li><p>Window-1252 (or ANSI-1252) - default code page for legacy Windows OS <img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/Windows-1252.png" alt="Windows 1252" data-proofer-ignore></p><li><p>CP437 (also known as OEM 437, or DOS Latin the US) - an original code page for IBM PC. <img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/CP_437.png" alt="CP 437" data-proofer-ignore></p><li><p>ISO-8859-1, aka Latin-1 (also useful for any Western European language) <img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/ISO-8859-1.png" alt="ISO-8859-1" data-proofer-ignore></p></ul><p>Now, if you wanted to write textual content using Cyrillic you would use <a href="https://en.wikipedia.org/wiki/Windows-1251">Windows-1251</a> encoding. When you transmit this data, the other party would need to use the same encoding scheme (code page) to successfully read the data they received. If the encoding scheme is not the same, the text would appear as if written in a different language.</p><p>If not explicitly set, ISO 8859‚Äì1 was the default encoding of the document delivered via <strong>HTTP</strong> with the <strong>MIME Type</strong> beginning with <code class="language-plaintext highlighter-rouge">text/</code>. Since <strong>HTML5</strong> this was changed to <strong>UTF-8</strong>.</p><hr /><h1 id="unicode">Unicode</h1><p>Code pages solved only part of the problem - storing additional characters for other languages since ASCII was designed to be sufficient for the English alphabet.</p><p>For most European languages this was acceptable, but not a great solution. You could not for example write in <code class="language-plaintext highlighter-rouge">multiple languages</code> in the same textual file, because you can use only one code page while processing text.</p><p>A bigger issue than that was the lack of support for languages that have much more characters than available 128 spaces within ASCII extended 8-bit code pages. Some examples are Arabic, Hindu, and Chinese (which have more than 10 thousand symbols called <code class="language-plaintext highlighter-rouge">ideograms</code>, which are actual words rather than letters as we are used to in European languages for example).</p><p>In a response to all the problems ‚Äúcode pages‚Äù had been introduced, and a new standard was initiated named <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>. It was an attempt to make a huge single character set for all spoken languages and even some made-up ones and other signs such as emojis üéâ. The first version came out in 1991 and had many new versions since then, the latest one being in 2021 at the time of this writing. The <strong>Unicode Consortium</strong> also maintains the standard for <strong>UTF</strong> (Unicode Transformation Format) encodings. More on this later. But first‚Ä¶</p><hr /><h2 id="grapheme-and-code-point"><span class="mr-2">Grapheme and code point</span><a href="#grapheme-and-code-point" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Up until now, we described all characters as self-contained symbols that can be represented with a single binary number in the encoding schema.</p><p>In simple words, the letter <code class="language-plaintext highlighter-rouge">A</code> is just encoded with some binary number (0100 0001 in ASCII).</p><p>But, things got a lot more complicated when considering other languages.</p><p>Some languages have modifiers of the letters such as accent modifiers. One such example that is also used in the English language for some foreign words is √â (<a href="https://en.wikipedia.org/wiki/%C3%89">e-acute</a>) which is an ordinary E letter with the acute symbol (that forward slash above the letter).</p><blockquote><p><strong>Diacritic</strong> - extra decoration for the character</p></blockquote><p>Grammar of some languages requires the use of diacritics for letters when certain conditions are met. Therefore, term <code class="language-plaintext highlighter-rouge">character</code> became ambiguous, so a new term is adopted for describing written symbols that could be with or without diacritics - a <code class="language-plaintext highlighter-rouge">grapheme</code>.</p><blockquote><p><strong>Grapheme</strong> is a single unit of human writing system. It may consist of one or more code points.</p></blockquote><p>As there can be a huge number of combinations of letters and their possible modifiers, instead of making an encoding schema for all of them, it‚Äôs much more efficient to encode them separately. Therefore we separate <strong>grapheme</strong> in <strong>code points</strong>.</p><blockquote><p><strong>Code point</strong> is any written symbol or it‚Äôs modifier like diacritic for letters, or even skin color of emojis</p></blockquote><p>So, one or more <strong>code points</strong> can make up a <strong>grapheme</strong>. Therefore, the Unicode character set is defined as a set of <strong>code points</strong> rather than a set of <strong>graphemes</strong>.</p><p>Some people believe that Unicode is just a simple 16-bit code where each character is mapped to a 16-bit number and so there are <code class="language-plaintext highlighter-rouge">2^16 = 65 536</code> possible code points. That is not the case and there are 144 697 defined characters at the time of writing this article.</p><p>What is true is that all characters that can fit into 2 bytes, in other words, <code class="language-plaintext highlighter-rouge">2^16 = 65 536</code> code points are considered to make up <strong>BMP</strong> - <strong>basic multilingual plane</strong> (<code class="language-plaintext highlighter-rouge">U+0000</code> to <code class="language-plaintext highlighter-rouge">U+FFFF</code>). This was the first attempt to unite all code points needed for storing textual data, but soon it became obvious that it needed even more space, so 2 bytes were not sufficient anymore.</p><p>Let‚Äôs go back to <code class="language-plaintext highlighter-rouge">√â</code> for a moment. This particular symbol can be encoded in two ways:</p><ul><li><p>using one code point that represents character <strong>√â</strong> (U+00C9)</p><li><p>using two code points, one for the letter <strong>E</strong> (U+0065) and its accent modifier (U+02CA)</p></ul><hr /><h2 id="codepoint-notation"><span class="mr-2">Codepoint notation</span><a href="#codepoint-notation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As we‚Äôve seen, the usual notation for Unicode characters is following:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>U+XXYY
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">U+</code> stands for <code class="language-plaintext highlighter-rouge">Unicode</code><li><code class="language-plaintext highlighter-rouge">XXYY</code> are bytes expressed in hexadecimal numbers (can be two or more)</ul><p>If we go back to √â described as 2 code points, we can easily track the first code point as hexadecimal <code class="language-plaintext highlighter-rouge">65</code>, which is indeed the letter <strong>E</strong> in the ASCII table.</p><p>Some graphemes have more than 2 bytes. For example <strong>thumbs up</strong> emoji üëç has the notation: <code class="language-plaintext highlighter-rouge">U+1F44D</code>.</p><hr /><h1 id="unicode-encoding-strategies">Unicode encoding strategies</h1><p>ASCII has a very simple encoding scheme. As it uses only one byte, it‚Äôs very easy to map all characters to binary format and vice-versa.</p><p>For Unicode, things are not that simple. There are varying lengths of code points, going from 1 up to 4 bytes in size.</p><p>Next, we‚Äôll take a look at the most interesting encoding schemes for Unicode. There are two groups of schemes:</p><ul><li>UCS - Universal Character Set<li>UTF - Unicode Transformation Format</ul><p>There are similarities and differences between them. We‚Äôll cover the most relevant in this article.</p><hr /><h1 id="utf-32-and-ucs-4">UTF-32 and UCS-4</h1><p>As the name suggests, UTF-32 consists of 32 bits, i.e. 4 bytes. This is the simplest encoding strategy. Every code point is converted to a 32-bit value. We‚Äôll see in short why this strategy is not very efficient in terms of space.</p><p>UCS-4 is the same in every aspect as UTF-32.</p><p>Let‚Äôs go back to our example from the beginning of this article with a simple change: let‚Äôs add emoji üöÄ between <code class="language-plaintext highlighter-rouge">world</code> and <code class="language-plaintext highlighter-rouge">!</code>:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Hello worldüöÄ!
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>Character<th>Hex<tbody><tr><td>H<td>00 00 00 48<tr><td>e<td>00 00 00 65<tr><td>l<td>00 00 00 6c<tr><td>l<td>00 00 00 6c<tr><td>o<td>00 00 00 6f<tr><td>&lt;space&gt;<td>00 00 00 20<tr><td>W<td>00 00 00 57<tr><td>o<td>00 00 00 6f<tr><td>r<td>00 00 00 72<tr><td>l<td>00 00 00 6c<tr><td>d<td>00 00 00 64<tr><td>üöÄ<td>00 01 F4 4D<tr><td>!<td>00 00 00 21</table></div><p>Do you notice something? For the majority of the content, we use much more space than needed. All ASCII characters require just one byte of space, but here we are spending additional 3 bytes per code point, which are all zeros. In other words, UTF-32 wastes a lot of memory for ASCII characters. If the text consists of only ASCII characters, UTF-32 would be 4X larger than the ASCII representation of the same text!</p><p>One advantage that UTF-32 has over other Unicode encoding schemes is that because of its simplicity, it‚Äôs easy to index code points in a file. As you only need to go 4 bytes per code point, so you can go to the desired index very fast, in both the forward and backward directions.</p><p>What happens case when the ASCII text processor tries to read out UCS-4 encoded string? In ASCII text processors, the end of a string is usually presented with 0x00, which means that string is going to be terminated once it comes across a byte that has all zeros. So, it would not read the text till the end if it consists of code points that are less than 4 bytes in size.</p><p>UTF-32/UCS-4 is not in use anymore by modern text processors, instead, you will find UTF-16 or UTF-8.</p><hr /><h1 id="ucs-2">UCS-2</h1><p>Remember <strong>BMP</strong> (Basic Multilingual Plane)? We said that all characters that fit into 2 bytes are considered to be part of <strong>BMP</strong>. UCS-2 was exactly that - 2 bytes per code-point and nothing more!</p><p>As this was an improvement over 8-bit code pages, it‚Äôs still not enough to represent more and more demanding and ever-expanding Unicode character set, so it quickly became obsolete in favor of a more flexible, yet very similar UTF-16 encoding scheme.</p><p>Here is a quick overview of support for code points using different encoding schemes:</p><div class="table-wrapper"><table><thead><tr><th>Code point<th>Binary value<th>ASCII <br /> support<th>UCS-2 <br /> support<th>UTF-32 / <br /> UTF-16 / <br /> UTF-8 <br /> support<tbody><tr><td>E<td>01000101<td>‚úÖ<td>‚úÖ<td>‚úÖ<tr><td>Œ¶<td>00000011 10100110<td>‚ùå<td>‚úÖ<td>‚úÖ<tr><td>üöÄ<td>00000000 00000001 11110110 10000000<td>‚ùå<td>‚ùå<td>‚úÖ</table></div><hr /><h1 id="utf-16">UTF-16</h1><p>This encoding scheme uses either 2 or 4 bytes to represent a single code point, so it‚Äôs not limited to UCS-2 to only 65 536 code points.</p><p>The majority of the code points that takes up to 16 bits can be directly converted in the same way as UCS-2 is doing - just a simple binary representation of the code point hexadecimal value.</p><p>The mechanism it uses is called <strong>surrogate pairs</strong>.</p><hr /><h2 id="surrogate-pairs"><span class="mr-2">Surrogate pairs</span><a href="#surrogate-pairs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>It‚Äôs easier to look at an example of how a code point is encoded with the UTF-16 encoding scheme.</p><p>Let‚Äôs take emoji like üöÄ that has Unicode value <code class="language-plaintext highlighter-rouge">U+1F680</code>.</p><p>Its binary form is:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>00000000 00000001 11110110 10000000
</pre></table></code></div></div><p>Now, we see that it goes over 16 bits in size. To represent a character of more than 16 bits in size, we need to use a ‚Äúsurrogate pair‚Äù, with which we get a single supplementary character. The first (high) surrogate is a 16-bit code value in the range <code class="language-plaintext highlighter-rouge">U+D800</code> to <code class="language-plaintext highlighter-rouge">U+DBFF</code>, and the second (low) surrogate is a 16-bit code value in the range <code class="language-plaintext highlighter-rouge">U+DC00</code> to <code class="language-plaintext highlighter-rouge">U+DFFF</code>.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>High surrogate format: 110110XX XXXXXXXX
Low surrogate format: 110111XX XXXXXXXX
</pre></table></code></div></div><blockquote class="prompt-tip"><div><p>High and low surrogate pairs exist so we can know if we are in the middle of the character when parsing data encoded in UTF-16.</p></div></blockquote><p>Now, we need to subtract <code class="language-plaintext highlighter-rouge">1 00000000 00000000</code> from the binary representation of emoji.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  00000000 00000001 11110110 10000000
- 00000000 00000001 00000000 00000000

= 00000000 00000000 11110110 10000000
</pre></table></code></div></div><p>Then, we are going to take the lower 20 binary digits:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>0000 11110110 10000000
</pre></table></code></div></div><p>And replace <code class="language-plaintext highlighter-rouge">X</code> signs in high and low surrogate with bits we just calculated:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>0000 11110110 10000000

// Split in half:
00 00111101
10 10000000

// Replace Xs in High and Low surrogate
High surrogate mask: 110110XX XXXXXXXX
Low surrogate mask: 110111XX XXXXXXXX

High surrogate value: 11011000 00111101
Low surrogate value: 11011110 10000000
</pre></table></code></div></div><p>And there you have it! Emoji üöÄ is represented in UTF-16 encoding schemes with 4 bytes:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>11011000 00111101 11011110 10000000
</pre></table></code></div></div><hr /><h1 id="unicode-restricted-code-points">Unicode restricted code points</h1><p>It‚Äôs important to note that since we are using surrogate pairs for marking 4-byte UTF-16 code points, we cannot use ranges for a high and low surrogate for 16-bit code points:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>High surrogate unavailable range: 11011000 00000000 (D800) to 11011011 11111111 (DBFF)
Low surrogate unavailable range: 11011100 00000000 (DC00) to 11011111 11111111 (DFFF)
</pre></table></code></div></div><p>You can notice that these two ranges makes one continuous range:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Surrogate unavailable range: 11011000 00000000 (D800) to 11011111 11111111 (DFFF)
</pre></table></code></div></div><p>In this range, there are no code points, in other words, this hole makes <code class="language-plaintext highlighter-rouge">2^11 = 2048</code> unavailable code points.</p><p>Because of these restrictions, designers of the Unicode standard decided to exclude the same range of code points from UCS-2, so UTF-16 is fully compatible with UCS-2 for all 2-byte-sized code points.</p><p>This restricted range is the same for all Unicode encodings.</p><h1 id="unicode-table">Unicode table</h1><p>The site https://unicode-table.com/ contains a lot of useful information regarding Unicode characters. We can even check the info page for üöÄ emoji here: https://unicode-table.com/en/1F680/ to verify we get the correct value for our example for UTF-16 encoding.</p><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/rocket_emoji.png" alt="Rocket emoji" data-proofer-ignore></p><p>Here we can see basic info, like:</p><ul><li>Unicode value<li>HTML code (essentially a decimal value)<li>CSS-code (hexadecimal value in a different format than Unicode notation)</ul><p>Near the end of the page, you can check out Encoding values for this Unicode code point:</p><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/rocket_emoji_encodings.png" alt="Rocket emoji encodings" data-proofer-ignore></p><p>As you can see, we successfully calculated UTF-16 encoding, yeah ü•≥!</p><p>But wait, you might ask what are now these 2 variations of UTF-16 called <code class="language-plaintext highlighter-rouge">UTF-16BE</code> and <code class="language-plaintext highlighter-rouge">UTF-16LE</code> ü§î? That brings us to the next topic‚Ä¶..</p><hr /><h1 id="endianness">Endianness</h1><p>The order of the bytes for multi-byte in which they are stored in memory is called <code class="language-plaintext highlighter-rouge">Endianness</code> of the computer system. Depending on the place of the <code class="language-plaintext highlighter-rouge">MSB</code> (Most Significant Byte) and <code class="language-plaintext highlighter-rouge">LSB</code> (Least Significant Byte) there are:</p><ul><li><code class="language-plaintext highlighter-rouge">BE</code> - Big-endian (<code class="language-plaintext highlighter-rouge">MSB</code> is stored at the smallest memory address)<li><code class="language-plaintext highlighter-rouge">LE</code> - Little-endian (<code class="language-plaintext highlighter-rouge">LSB</code> is stored at the smallest memory address)</ul><p>Why does this matter in the first place?</p><p>CPU usually does not take one byte when processing data, but it takes multiple bytes. This measure is called <code class="language-plaintext highlighter-rouge">word</code> in CPU terminology. It becomes natural that the size <code class="language-plaintext highlighter-rouge">word</code> is multiple of 8 since the smallest unit for storage is <code class="language-plaintext highlighter-rouge">byte</code> (8 bits). Modern CPUs are 32-bit or 64-bit in size.</p><p>Most modern computer systems (Intel processors for example) use a <strong>little-endian</strong> format to store the data in the memory. The reason is beyond the scope of this article, but it‚Äôs related to the internal structure of the CPU since particular endianness allows for certain features on different CPU designs.</p><p>If we have 32-bit integer number like <code class="language-plaintext highlighter-rouge">42</code> for example, we would write it in binary format as:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>// Big Endian
MSB                                 LSB
0000 0000 | 0000 0000 | 0000 0000 | 0010 1010   &lt;- binary representation
0x00      | 0x01      | 0x02      | 0x03        &lt;- memory address


// Little Endian
LSB                                 MSB
0010 1010 | 0000 0000 | 0000 0000 | 0000 0000   &lt;- binary representation
0x00      | 0x01      | 0x02      | 0x03        &lt;- memory address
</pre></table></code></div></div><p>Now, you can see that if we didn‚Äôt know what was the endianness, we could interpret this integer number in the wrong way.</p><p>For our example, instead of reading <code class="language-plaintext highlighter-rouge">42</code>, we could by mistake think it‚Äôs <code class="language-plaintext highlighter-rouge">704 643 072</code>!</p><p>Now that you understand the implications of using the wrong endian in processing data, let‚Äôs go back to Unicode.</p><p>Text processors need to know how to parse the text. That‚Äôs where Endianness comes into the picture.</p><p>All Unicode encodings use at least 2 bytes of data per code point, meaning that the CPU is storing multiple bytes at once in either <code class="language-plaintext highlighter-rouge">BE</code> or <code class="language-plaintext highlighter-rouge">LE</code>.</p><hr /><h1 id="bom---byte-order-mark">BOM - Byte Order Mark</h1><p>A little trick we can use to make sure proper endianness is applied when reading files written in Unicode encodings is the so-called <strong>Byte Order Mark</strong> or <strong>BOM</strong> for short.</p><p>Let‚Äôs take a look at the UTF-16 example.</p><p><strong>BOM</strong> is nothing more than a code point that has a special property.</p><p>Its Unicode value is <code class="language-plaintext highlighter-rouge">U+FEFF</code> and it represents ‚Äúzero-width, non-breaking space‚Äù.</p><p>What that means is this code point is not visible on screen, yet it is a valid code point for UTF-16 encoding.</p><p>But, the catch is that if we reverse the order of the bytes to <code class="language-plaintext highlighter-rouge">U+FFFE</code> we get to a value that is considered invalid for UTF-16 encoding. Hence, the text processor understands that it needs to read the bytes in a different order, using Little Endian.</p><p>What a nice little trick üôÇ!</p><p>To use BOM, these 2 bytes will be saved at the beginning of a file, so the text processor can immediately figure out what Endianness is used for the file.</p><p>Now, to demonstrate this, I will show how it looks when saving characters <code class="language-plaintext highlighter-rouge">abcde</code> in a file using UTF-16 LE and UTF-16 BE:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>// When saved as UTF-16 LE it will keep LSB on lowest memory address 

FF FE 61 00 62 00 63 00 64 00 65 00
</pre></table></code></div></div><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/UTF-16_Little_Endian_demo.gif" alt="Little endian demo" data-proofer-ignore></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>// When saved as UTF-16 BE it will keep LSB on lowest memory address 

FF FE 61 00 62 00 63 00 64 00 65 00
</pre></table></code></div></div><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/UTF-16_Big_Endian_demo.gif" alt="Big endian demo" data-proofer-ignore></p><blockquote class="prompt-warning"><div><p>If BOM is not set for UTF-16, it is assumed that Big endian is used.</p></div></blockquote><hr /><h1 id="utf-8">UTF-8</h1><p>This brilliant encoding scheme is one of the most used today alongside <code class="language-plaintext highlighter-rouge">UTF-16</code>, because of its very useful features.</p><p>Code points that take 1 byte of size and are encoded with the same scheme as ASCII encoding. For all other code points, <code class="language-plaintext highlighter-rouge">UTF-8</code> uses from 2 up to 4 bytes (even 6 in some cases), depending on the code point itself.</p><p>What this encoding allows as a bonus is backward compatibility with ASCII encoded files, as all ASCII characters would be read properly. This is not the case with <code class="language-plaintext highlighter-rouge">UTF-32</code>, <code class="language-plaintext highlighter-rouge">UTF-16</code>, and <code class="language-plaintext highlighter-rouge">UCS-2</code> encoding schemes, as they expect the exact number of bytes per code point (4 for <code class="language-plaintext highlighter-rouge">UTF-32</code>, 2 for <code class="language-plaintext highlighter-rouge">UCS-2</code> and 2-4 for <code class="language-plaintext highlighter-rouge">UTF-16</code>).</p><p>Also, programs that use ASCII encoding can read files written in the <code class="language-plaintext highlighter-rouge">UTF-8</code> schema, as long as they used only ASCII characters.</p><p>What is the downside of the <code class="language-plaintext highlighter-rouge">UTF-8</code> encoding scheme? It should be obvious by now, that it‚Äôs the fact that code points are variable in size, so it‚Äôs hard to index code points in a file (in other words searching for the n-th character in the file), in contrast to <code class="language-plaintext highlighter-rouge">UTF-32</code> and <code class="language-plaintext highlighter-rouge">UTF-16</code> encoding schemes.</p><p>Another downside is that it uses 50% more space than <code class="language-plaintext highlighter-rouge">UTF-16</code> for East Asian text.</p><p><code class="language-plaintext highlighter-rouge">UTF-8</code> also has the nice property that ignorant old string-processing code that wants to use a single 0 byte as the null-terminator will not truncate strings, as is the case with other encoding schemes.</p><hr /><h2 id="utf-8-encoding-algorithm"><span class="mr-2">UTF-8 encoding algorithm</span><a href="#utf-8-encoding-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The encoding algorithm that is used for UTF-8 is very simple, yet brilliant!</p><p>It can be summarized in the following rules:</p><ol><li>If the code point is in the range of ASCII characters, it is encoded in the same way as ASCII. Simple as that!<li>For other characters, we need to use more than one byte, in the following way:<ol><li>The first byte must start with the same number of zeros as the number of bytes that will be used for this code point, followed by a zero.<li>Every other byte must start with <code class="language-plaintext highlighter-rouge">10</code>.<li>Once we create such <strong>masked</strong> bytes, we fill in the binary form of the code point in data spaces.</ol></ol><p>As this was a mouthful, let‚Äôs go over some examples to better understand this process.</p><hr /><h3 id="example-1"><span class="mr-2">Example 1</span><a href="#example-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Character <code class="language-plaintext highlighter-rouge">A</code> falls in a range of ASCII characters. Therefore, it‚Äôs encoded using ASCII encoding like this:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>01000001
</pre></table></code></div></div><hr /><h3 id="example-2"><span class="mr-2">Example 2</span><a href="#example-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Greek letter <strong>Œ¶</strong> has a Unicode code point <code class="language-plaintext highlighter-rouge">U+03A6</code>.</p><p>Its binary form is:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>00000011 10100110
</pre></table></code></div></div><p>As we can see, it has more than 7 bits in size, hence we need to use step 2. in the algorithm for encoding this code point to UTF-8.</p><p>Let‚Äôs check if 2 bytes will be enough to encode this code point. In such a case, the first byte will have the following mask:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>// Number of ones == number of bytes, then 0
110XXXXX
</pre></table></code></div></div><p>Next byte would have a mask:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>10XXXXXX
</pre></table></code></div></div><p>If we count up X signs, we see that we have 11 spaces for binary representation of Unicode code point.</p><p>As our code point from example, <strong>Œ¶</strong> can fit in 10 binary digits, 2 bytes is enough for this code point.</p><p>What is left to do is to replace masks with binary digits that represent our Unicode code point:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>11001110 10100110
</pre></table></code></div></div><p>Or, in hexadecimal, we get <code class="language-plaintext highlighter-rouge">CE A6</code>.</p><p>If you check https://unicode-table.com/en/03A6/, you can verify we got the correct value. Yeah ü•≥!</p><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/UTF-8_example_2.png" alt="UTF-8 example 2" data-proofer-ignore></p><hr /><h3 id="example-3"><span class="mr-2">Example 3</span><a href="#example-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>For the final example, let‚Äôs take one more look at the üöÄ emoji.</p><p>Binary form:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>00000000 00000001 11110110 10000000
</pre></table></code></div></div><p>As this one needs 17 bits, it will not fit in 2 bytes for the UTF-8 encoding.</p><p>It will not fit into 3 bytes as well, because:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>1110XXXX 10XXXXXX 10XXXXXX
</pre></table></code></div></div><p>This gives us 16 bits of space, but we need 17.</p><p>So, we need 4 bytes:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
</pre></table></code></div></div><p>This gives us <code class="language-plaintext highlighter-rouge">3x6+3 = 21</code> bits of space for Unicode code points.</p><p>Now, let‚Äôs populate masked bits and we get:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>11110000 10011111 10011010 10000000
</pre></table></code></div></div><p>Which is <code class="language-plaintext highlighter-rouge">F0 9F 9A 80</code> in hexadecimal. You can verify it here: https://unicode-table.com/en/1F680/</p><h2 id="utf-8-encoding-summary"><span class="mr-2">UTF-8 encoding summary</span><a href="#utf-8-encoding-summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Here is a summary of code point ranges and their respective UTF-8 byte sizes:</p><div class="table-wrapper"><table><thead><tr><th>Bits of code point<th>First code point<th>Last code point<th>Bytes in sequence<th>Byte 1<th>Byte 2<th>Byte 3<th>Byte 4<th>Byte 5<th>Byte 6<tbody><tr><td>7<td>U+0000<td>U+007F<td>1<td>0xxxxxxx<td>¬†<td>¬†<td>¬†<td>¬†<td>¬†<tr><td>11<td>U+0080<td>U+07FF<td>2<td>110xxxxx<td>10xxxxxx<td>¬†<td>¬†<td>¬†<td>¬†<tr><td>16<td>U+0800<td>U+FFFF<td>3<td>1110xxxx<td>10xxxxxx<td>10xxxxxx<td>¬†<td>¬†<td>¬†<tr><td>21<td>U+10000<td>U+1FFFFF<td>4<td>11110xxx<td>10xxxxxx<td>10xxxxxx<td>10xxxxxx<td>¬†<td>¬†<tr><td>26<td>U+200000<td>U+3FFFFFF<td>5<td>111110xx<td>10xxxxxx<td>10xxxxxx<td>10xxxxxx<td>10xxxxxx<td>¬†<tr><td>31<td>U+400000<td>U+7FFFFFFF<td>6<td>1111110x<td>10xxxxxx<td>10xxxxxx<td>10xxxxxx<td>10xxxxxx<td>10xxxxxx</table></div><hr /><h2 id="what-about-bom-for-utf-8"><span class="mr-2">What about BOM for UTF-8?</span><a href="#what-about-bom-for-utf-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>For UTF-8 there is also a possibility to define BOM in the same way as for UTF-16.</p><p>We know that BOM code point is <code class="language-plaintext highlighter-rouge">FE FF</code>. Binary form is:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>11111110 11111111
</pre></table></code></div></div><p>As we‚Äôve seen in an exercise just before, since this code point is more than 8 bits in size, we need to use multiple bytes. In this case, we need to use 3 bytes, as it gives us 16 bits of space, which is exactly how much we need to represent this code point.</p><p>We already know that the first byte must start with several ones that represent how many bytes this code point requires by UTF-8 encoding (in this case 3), followed by zero. For other bytes, they must start with <code class="language-plaintext highlighter-rouge">10</code>:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>// First byte mask
1110xxxx

// Other bytes masks
10xxxxxx
10xxxxxx
</pre></table></code></div></div><p>So, complete mask for our <code class="language-plaintext highlighter-rouge">FE FF</code> code point is:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>1110xxxx 10xxxxxx 10xxxxxx
</pre></table></code></div></div><p>Now what is left is to populate <code class="language-plaintext highlighter-rouge">x</code> signs with bits themselves. We finally get:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>11101111 10111011 10111111
</pre></table></code></div></div><p>Or, in hexadecimal:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>EF BB BF
</pre></table></code></div></div><p>If file is saved in <code class="language-plaintext highlighter-rouge">UTF-8 with BOM</code> encoding scheme, it‚Äôs first three bytes will be:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>// Big Endian
EF BB BF

// Little Endian
BF BB EF
</pre></table></code></div></div><p>Here is another demo of a file saved in <code class="language-plaintext highlighter-rouge">UTF-8 BOM</code> encoding:</p><p><img data-src="/assets/img/posts/2022-07-16-character-encoding-demystified/UTF-8_BOM_demo.gif" alt="UTF-8 BOM demo" data-proofer-ignore></p><blockquote class="prompt-warning"><div><p>As is the case with UTF-16, if BOM is not present, assumed is Big Endian.</p></div></blockquote><hr /><h1 id="programming-languages-character-encodings">Programming languages character encodings</h1><p>In most tutorials for beginners in any programming language, you learn how to print out the console famous ‚Äú<strong>Hello world!</strong>‚Äù sentence.</p><p>As it would be overkill for a beginner student to learn all about character encodings, this information is usually left out.</p><p>But it‚Äôs very important to know that not all programming languages are Unicode aware (meaning they operate on a sequence of Unicode characters rather than ASCII characters).</p><p>Here is a list of some mainstream programming languages and their default character encodings:</p><div class="table-wrapper"><table><thead><tr><th>Programming language<th>Default character encoding<th>Unicode aware<tbody><tr><td>C/C++<td>ASCII<td>‚ùå<tr><td>Java<td>UTF-16 (first versions used UCS-2)<td>‚úÖ<tr><td>C#<td>UTF-16<td>‚úÖ<tr><td>Javascript<td>UTF-16<td>‚úÖ<tr><td>PHP<td>ASCII<td>‚ùå<tr><td>Python 2<td>ASCII<td>‚ùå<tr><td>Python 3<td>UTF-8<td>‚úÖ</table></div><p>This overview shows only the default character encoding used by these programming languages, it does not mean they cannot process Unicode text. They all have support for Unicode, either through additional data types or 3rd party libraries.</p><p>The key point to take away from here is that you should be aware of the limitations your programming language has when processing data, otherwise you can get in all kinds of funny situations. For example, counting the number of characters in Unicode text that has at least one character outside the ASCII range using C++ <code class="language-plaintext highlighter-rouge">char</code> datatype would give you the wrong result.</p><hr /><h1 id="db-unicode-support">DB Unicode support</h1><p>For most DB engines there are, either SQL or NoSQL, there are settings per-database level where you can choose character encoding by yourself.</p><p>All modern DB engines have support for Unicode, but you need to be cautious when choosing encoding schema.</p><hr /><h2 id="mysql"><span class="mr-2">MySQL</span><a href="#mysql" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>For example, there is a case of MySQL server that has an encoding scheme called ‚Äúutf8‚Äù, which is just an alias for ‚Äúutfmb3‚Äù. What it represents is UTF-8 with <strong>M</strong>aximum <strong>B</strong>ytes <strong>3</strong>.</p><p>As shown in section ‚ÄúUTF-8 encoding summary‚Äù, we can see that with 3 bytes you can store only a range from <code class="language-plaintext highlighter-rouge">U+0000</code> up to <code class="language-plaintext highlighter-rouge">U+FFFF</code>, so-called <strong>BMP</strong> (Basic Multilingual Plane).</p><blockquote class="prompt-danger"><div><p>In <strong>MySQL</strong>, the encoding scheme ‚Äúutf8‚Äù cannot store Unicode code points outside Basic Multilingual Plane!</p></div></blockquote><p>Therefore, the recommended character encoding is ‚Äúutf8mb4‚Äù, which allows up to 4 bytes in size.</p><hr /><h1 id="transmitting-strings-over-the-network">Transmitting strings over the network</h1><p>When sending data over a network, the recipient does not know the character encoding used to create that data. So, if you don‚Äôt specify it somehow, the recipient can only guess what encoding to use to read the content.</p><h2 id="e-mail-encoding"><span class="mr-2">E-mail encoding</span><a href="#e-mail-encoding" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>When sending e-mail messages you should (e-mail client actually) write a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type">Content-Type</a> HTTP header. It is used to indicate <a href="https://developer.mozilla.org/en-US/docs/Glossary/MIME_type">MIME</a> type, where text can be one of the values. An example of UTF-8 encoding would be:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Content-Type: text/plain; charset="UTF-8"
</pre></table></code></div></div><h2 id="html-encoding"><span class="mr-2">HTML encoding</span><a href="#html-encoding" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As for the HTML pages, the encoding scheme is set up inside the same HTML file, with a special tag.</p><div class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="HTML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
...
</pre></table></code></div></div><p>Now you may wonder how a text processor (in this case web browser) can even read the first part of the HTML without knowing the character encoding used?</p><p>If you take a look at the code we just wrote, you can notice that all the characters used in this part of the file are in a range of ASCII printable characters. That allows for any ASCII-compatible encoding scheme (the vast majority of encoding schemes in use today) to read this part of the file.</p><p>After the charset is read by a web browser, it can switch to a different encoding scheme if needed.</p><blockquote class="prompt-warning"><div><p><strong>meta</strong> tag for declaring charset in HTML should be the first thing in &lt;head&gt; tag, for 2 reasons:</p><ul><li>if something other than ASCII comes before this meta tag, you compromise the browser‚Äôs ability to read the proper charset and therefore the page can appear ‚Äúbroken‚Äù.<li>as soon as the browser read the charset it will stop parsing the page and it will start from the beginning using the specified encoding scheme.</ul></div></blockquote><p>You may ask what happens if there is no <strong>charset</strong> defined in HTML? Did the browser try to guess the encoding, or it will just use some default encoding scheme? Well, browsers do try to guess the encoding based on statistics on how many times particular characters appear in a text. As you may assume, it was not very successful in achieving a good result.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/encoding/'>encoding</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/encoding/" class="post-tag no-text-decoration" >encoding</a> <a href="/tags/ascii/" class="post-tag no-text-decoration" >ascii</a> <a href="/tags/unicode/" class="post-tag no-text-decoration" >unicode</a> <a href="/tags/utf-8/" class="post-tag no-text-decoration" >utf-8</a> <a href="/tags/utf-16/" class="post-tag no-text-decoration" >utf-16</a> <a href="/tags/string/" class="post-tag no-text-decoration" >string</a> <a href="/tags/crlf/" class="post-tag no-text-decoration" >crlf</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Character+Encoding+Demystified%3A+Everything+you+Need+to+Know+About+ASCII%2C+Unicode%2C+UTF-8+-+Borko+Rajkovic+Tech+Blog&url=https%3A%2F%2Fborkorajkovic.com%2F%2Fposts%2Fcharacter-encoding-demystified%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Character+Encoding+Demystified%3A+Everything+you+Need+to+Know+About+ASCII%2C+Unicode%2C+UTF-8+-+Borko+Rajkovic+Tech+Blog&u=https%3A%2F%2Fborkorajkovic.com%2F%2Fposts%2Fcharacter-encoding-demystified%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fborkorajkovic.com%2F%2Fposts%2Fcharacter-encoding-demystified%2F&text=Character+Encoding+Demystified%3A+Everything+you+Need+to+Know+About+ASCII%2C+Unicode%2C+UTF-8+-+Borko+Rajkovic+Tech+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/floyd-cycle-detection/">Floyd cycle detection</a><li><a href="/posts/generics-in-java-part-1-of-3/">Generics in Java part 1 of 3</a><li><a href="/posts/generics-in-java-part-2-of-3/">Generics in Java part 2 of 3</a><li><a href="/posts/sql-unique-vs-distinct/">SQL: NULL values in UNIQUE vs DISTINCT</a><li><a href="/posts/character-encoding-demystified/">Character Encoding Demystified: Everything you Need to Know About ASCII, Unicode, UTF-8</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/generics/">generics</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/ascii/">ascii</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/puzzle/">puzzle</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/typescript/">typescript</a> <a class="post-tag" href="/tags/utf-16/">utf-16</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/string-pool-in-java/"><div class="card-body"> <em class="small" data-ts="1659113400" data-df="ll" > Jul 29, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>String pool in Java</h3><div class="text-muted small"><p> In this post you will learn about String constant pool (or String pool for short) in Java. Knowing about String pool will deepen your knowledge of Java internals, which is always a plus for a Soft...</p></div></div></a></div><div class="card"> <a href="/posts/building-linux-from-scratch/"><div class="card-body"> <em class="small" data-ts="1746518700" data-df="ll" > May 6, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Building Linux From Scratch: A Journey into the Heart of Linux</h3><div class="text-muted small"><p> Introduction After over a decade of using Linux, primarily Ubuntu, I felt it was time to delve deeper into the system‚Äôs internals. My goal was to understand how Linux operates beneath the surfac...</p></div></div></a></div><div class="card"> <a href="/posts/scout-rule/"><div class="card-body"> <em class="small" data-ts="1722117900" data-df="ll" > Jul 28, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scout Rule</h3><div class="text-muted small"><p> The ‚ÄúScout Rule‚Äù is derived from the Boy Scouts‚Äô motto: ‚ÄúLeave the campground cleaner than you found it.‚Äù In the context of software development, it emphasizes the idea of leaving the codebase bett...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/welcome-to-my-blog/" class="btn btn-outline-primary" prompt="Older"><p>Welcome to my blog</p></a> <a href="/posts/string-pool-in-java/" class="btn btn-outline-primary" prompt="Newer"><p>String pool in Java</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "borko-rajkovic/borko-rajkovic.github.io", "data-repo-id": "R_kgDOHosKmQ", "data-category": "", "data-category-id": "DIC_kwDOHosKmc4CQJ0g", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> ¬© 2025 <a href="https://twitter.com/borko_88">Borko Rajkoviƒá</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/generics/">generics</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/ascii/">ascii</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/puzzle/">puzzle</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/typescript/">typescript</a> <a class="post-tag" href="/tags/utf-16/">utf-16</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
